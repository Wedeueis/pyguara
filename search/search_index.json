{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to PyGuara","text":"<p>PyGuara is a modern, modular, and high-performance 2D game engine for Python 3.12+. It is built with a focus on clean architecture, decoupling, and developer productivity.</p>"},{"location":"#architectural-pillars","title":"\ud83c\udfd7\ufe0f Architectural Pillars","text":"<p>PyGuara is built on four core pillars:</p> <ol> <li>Decoupled Logic: Using a robust Entity-Component-System (ECS) and Dependency Injection to keep your game code clean and testable.</li> <li>Flexible Rendering: A multi-pass render graph with material system, dynamic 2D lighting, and post-processing effects (bloom, vignette).</li> <li>Physical Simulation: Native integration with Pymunk for 2D physics.</li> <li>Extensible Systems: Comprehensive suites for AI, UI, Audio, and Resource Management.</li> </ol>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":""},{"location":"#guides-standards","title":"Guides &amp; Standards","text":"<p>Start here to understand how we work: *   Onboarding: Your first stop. Learn the core patterns (DI, ECS, Events). *   Architecture &amp; Style: Coding standards, file organization, and SOLID principles. *   Project Structure: How to organize your game files and assets. *   Brand Identity: The \"Maned Wolf &amp; Falcon\" aesthetic.</p>"},{"location":"#core-architecture","title":"Core Architecture","text":"<p>Understand the foundational systems: *   ECS: High-performance entity management with inverted indexing. *   Dependency Injection: Auto-wired service management. *   Event System: Thread-safe, decoupled communication. *   Logging: Standardized logging configuration.</p>"},{"location":"#application-lifecycle","title":"Application &amp; Lifecycle","text":"<p>How the engine starts and runs: *   Bootstrapping: The Composition Root pattern. *   Configuration: Validated JSON-based settings. *   Error Handling: Exception hierarchy and recovery strategies.</p>"},{"location":"#graphics-ui","title":"Graphics &amp; UI","text":"<p>Bringing your game to life: *   Render Graph: Multi-pass pipeline (World \u2192 Light \u2192 Composite \u2192 Post-Process \u2192 UI). *   Material System: Shader + Texture + Uniforms with automatic batching. *   2D Lighting: Dynamic lights with color, radius, intensity, and falloff. *   Post-Processing: Bloom, vignette, and chainable screen-space effects. *   Camera &amp; Viewports: Managing coordinates and screen regions. *   UI System: Flexible, themeable widget system.</p>"},{"location":"#physics-simulation","title":"Physics &amp; Simulation","text":"<p>Interactions and world dynamics: *   Physics: Rigid bodies, colliders, and raycasting.</p>"},{"location":"#ai-logic","title":"AI &amp; Logic","text":"<p>Creating intelligent behaviors: *   Behavior Trees: Complex hierarchical decision making. *   FSM: Finite State Machines. *   Pathfinding: A* and Navmesh support.</p>"},{"location":"#systems-tools","title":"Systems &amp; Tools","text":"<p>Essential engine features: *   Input System: Action-based input mapping for Keyboard/Gamepad. *   Animation: Powerful tweening and easing system. *   Scripting: Coroutine-based sequential logic. *   Resources: Caching and type-safe asset loading. *   Editor &amp; Tools: In-game debug overlay and inspector.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>If you haven't already, check the README for installation instructions. To run the default example, simply execute:</p> <pre><code>python main.py\n</code></pre>"},{"location":"ai/intelligence/","title":"AI System","text":"<p>The AI module (<code>pyguara.ai</code>) provides a robust suite of tools for creating intelligent agents, from simple state machines to complex behavior trees.</p>"},{"location":"ai/intelligence/#behavior-trees","title":"\ud83e\udde0 Behavior Trees","text":"<p>PyGuara features a professional-grade Behavior Tree (BT) implementation, perfect for complex decision-making.</p>"},{"location":"ai/intelligence/#core-components","title":"Core Components","text":"<ul> <li>BehaviorTree: The runner that executes the tree.</li> <li>Nodes:<ul> <li>ActionNode: Executes a function (Leaf). Returns <code>SUCCESS</code>, <code>FAILURE</code>, or <code>RUNNING</code>.</li> <li>ConditionNode: Checks a boolean predicate (Leaf).</li> <li>SequenceNode: Runs children in order until one fails (AND logic).</li> <li>SelectorNode: Runs children in order until one succeeds (OR logic).</li> <li>ParallelNode: Runs children simultaneously.</li> </ul> </li> <li>Decorators:<ul> <li><code>InverterNode</code>, <code>RepeaterNode</code>, <code>SucceederNode</code>, <code>UntilFailNode</code>.</li> </ul> </li> </ul>"},{"location":"ai/intelligence/#usage-example","title":"Usage Example","text":"<pre><code>from pyguara.ai.behavior_tree import BehaviorTree, SequenceNode, ActionNode, NodeStatus\n\ndef move_to_player(context):\n    # Logic...\n    return NodeStatus.SUCCESS\n\ndef attack_player(context):\n    # Logic...\n    return NodeStatus.SUCCESS\n\n# Define structure\nroot = SequenceNode([\n    ActionNode(move_to_player),\n    ActionNode(attack_player)\n])\n\n# Create component\nai_component = AIComponent()\nai_component.behavior_tree = BehaviorTree(root)\n</code></pre>"},{"location":"ai/intelligence/#finite-state-machines-fsm","title":"\ud83d\udd04 Finite State Machines (FSM)","text":"<p>For simpler logic, use the FSM system.</p> <ul> <li>State: Abstract base class with <code>on_enter</code>, <code>update</code>, <code>on_exit</code>.</li> <li>StateMachine: Manages current state and transitions.</li> </ul>"},{"location":"ai/intelligence/#pathfinding-steering","title":"\ud83e\udded Pathfinding &amp; Steering","text":"<ul> <li>AStarPathfinder: Grid and Graph based pathfinding.</li> <li>Steering: Common behaviors like <code>Seek</code>, <code>Flee</code>, and <code>Arrive</code> for natural movement.</li> <li>Navmesh: Tools for generating and navigating walkable surfaces.</li> </ul>"},{"location":"ai/intelligence/#blackboard","title":"\ud83d\udcdd Blackboard","text":"<p>The Blackboard pattern allows different AI systems (or nodes in a BT) to share data (e.g., \"TargetPosition\", \"AlertLevel\") without tight coupling.</p>"},{"location":"core/application/","title":"Application Lifecycle","text":"<p>The <code>pyguara.application</code> package manages the main game loop, initialization, and shutdown sequences.</p>"},{"location":"core/application/#the-application-class","title":"The Application Class","text":"<p>The <code>Application</code> class (<code>pyguara/application/application.py</code>) is the runtime coordinator. It is responsible for:</p> <ol> <li>Dependency Resolution: Retrieving core systems (Window, Input, SceneManager) from the DI Container.</li> <li>Main Loop:<ul> <li><code>Time.tick()</code></li> <li><code>Input.process()</code></li> <li><code>Update()</code> (Logic &amp; Physics)</li> <li><code>Render()</code></li> </ul> </li> </ol>"},{"location":"core/application/#bootstrapping","title":"Bootstrapping","text":"<p>The entry point is managed by <code>create_application()</code> in <code>bootstrap.py</code>. This implementation of the Composition Root pattern ensures that all dependencies are wired before the game starts.</p> <pre><code>def create_application() -&gt; Application:\n    container = DIContainer()\n    # ... register services ...\n    return Application(container)\n</code></pre>"},{"location":"core/application/#configuration","title":"Configuration","text":"<p>Configuration is managed by <code>ConfigManager</code> (<code>pyguara/config</code>), which handles: - Loading/Saving: JSON serialization. - Validation: Rules checking (e.g., \"Screen width must be &gt; 640\"). - Events: Dispatches <code>OnConfigurationChanged</code> when settings are modified.</p>"},{"location":"core/application/#error-handling","title":"Error Handling","text":"<p>The engine provides a centralized exception hierarchy in <code>pyguara.error</code>.</p> <ul> <li>EngineException: Base class for all engine errors.</li> <li>Categories: Errors are categorized (Graphics, Assets, Physics) for easier debugging.</li> <li>Safe Execution: Decorators like <code>@safe_execute</code> and <code>@retry</code> help manage instability in IO operations.</li> </ul>"},{"location":"core/architecture/","title":"Entity Component System (ECS)","text":"<p>PyGuara uses a performance-optimized ECS implementation designed to handle thousands of entities with minimal overhead.</p>"},{"location":"core/architecture/#architecture","title":"Architecture","text":"<p>The ECS is built around three main concepts:</p> <ol> <li>Entity: A unique ID acting as a container.</li> <li>Component: Pure data classes attached to entities.</li> <li>EntityManager: The database managing queries and lifecycles.</li> </ol>"},{"location":"core/architecture/#entitymanager","title":"EntityManager","text":"<p>The <code>EntityManager</code> (<code>pyguara.ecs.manager</code>) is the heart of the system. It employs an Inverted Index strategy for $O(1)$ component lookups, avoiding the common performance pitfall of iterating through all entities.</p> <p>Key Features: - Inverted Indexing: Maps <code>ComponentType -&gt; Set[EntityID]</code>. - Set Intersection Queries: Queries like \"Get all entities with <code>Transform</code> AND <code>RigidBody</code>\" are solved via fast set intersection.</p> <pre><code># O(K) complexity where K is the number of matching entities\nfor entity in manager.get_entities_with(Transform, RigidBody):\n    ...\n</code></pre>"},{"location":"core/architecture/#entity","title":"Entity","text":"<p>The <code>Entity</code> class (<code>pyguara.ecs.entity</code>) is a lightweight container.</p> <ul> <li>Dynamic Attribute Access: Components are cached, allowing pythonic access (e.g., <code>entity.rigid_body</code>) via <code>__getattr__</code> optimization.</li> <li>Tagging: Supports string-based tags for non-component filtering.</li> </ul>"},{"location":"core/architecture/#component","title":"Component","text":"<p>Components (<code>pyguara.ecs.component</code>) are defined as <code>dataclasses</code> or standard classes inheriting from <code>BaseComponent</code>.</p> <pre><code>@dataclass\nclass Health(BaseComponent):\n    current: float = 100.0\n    max: float = 100.0\n</code></pre>"},{"location":"core/architecture/#dependency-injection-di","title":"Dependency Injection (DI)","text":"<p>PyGuara features a native, reflection-based Dependency Injection container (<code>pyguara.di</code>).</p>"},{"location":"core/architecture/#features","title":"Features","text":"<ul> <li>Auto-Wiring: Uses Python type hints (<code>typing.get_type_hints</code>) and <code>inspect</code> to automatically resolve constructor dependencies.</li> <li>Cycle Detection: Detects and reports circular dependencies at runtime.</li> <li>Scopes:<ul> <li><code>SINGLETON</code>: Shared across the entire application.</li> <li><code>TRANSIENT</code>: Created new every time requested.</li> <li><code>SCOPED</code>: Shared within a specific context (e.g., a Scene).</li> </ul> </li> </ul>"},{"location":"core/architecture/#usage","title":"Usage","text":"<pre><code>container = DIContainer()\ncontainer.register_singleton(IPhysicsEngine, PymunkEngine)\n\n# Application is auto-wired with IPhysicsEngine\napp = container.get(Application)\n</code></pre>"},{"location":"core/architecture/#event-system","title":"Event System","text":"<p>The Event System (<code>pyguara.events</code>) provides a decoupled communication channel between subsystems.</p>"},{"location":"core/architecture/#eventdispatcher","title":"EventDispatcher","text":"<ul> <li>Synchronous Dispatch: <code>dispatch(event)</code> executes handlers immediately on the calling thread.</li> <li>Queued Dispatch: <code>queue_event(event)</code> is thread-safe and processes events at the start of the next frame (useful for Network/Loader threads).</li> <li>Filtering &amp; Priority: Handlers can define priority levels and filter logic.</li> </ul>"},{"location":"core/architecture/#protocol","title":"Protocol","text":"<p>Events are defined using the <code>Event</code> protocol, typically implemented as Dataclasses.</p> <pre><code>@dataclass\nclass PlayerDiedEvent:\n    player_id: str\n    timestamp: float = field(default_factory=time.time)\n    source: Any = None\n</code></pre>"},{"location":"core/logging/","title":"Logging System","text":"<p>PyGuara provides a centralized logging configuration (<code>pyguara.log</code>) wrapping Python's standard <code>logging</code> module. This ensures consistent log formatting, levels, and output destinations.</p>"},{"location":"core/logging/#setup","title":"Setup","text":"<p>Logging is initialized via <code>setup_logging</code> in <code>bootstrap.py</code>.</p> <pre><code>from pyguara.log.config import setup_logging\nimport logging\n\n# Configure console output and optional file output\nsetup_logging(\n    level=logging.INFO,\n    log_file=\"game.log\",\n    file_level=logging.DEBUG\n)\n</code></pre>"},{"location":"core/logging/#usage","title":"Usage","text":"<p>In any module, retrieve a namespaced logger:</p> <pre><code>from pyguara.log.config import get_logger\n\nlogger = get_logger(__name__)\n\ndef my_function():\n    logger.info(\"Function started\")\n    try:\n        # ... logic ...\n    except Exception:\n        logger.error(\"Critical failure\", exc_info=True)\n</code></pre>"},{"location":"core/logging/#best-practices","title":"Best Practices","text":"<ul> <li>Avoid <code>print()</code>: Always use the logger.</li> <li>Levels:<ul> <li><code>DEBUG</code>: High-frequency data (resource loads, events).</li> <li><code>INFO</code>: Lifecycle events (startup, scene switch).</li> <li><code>WARNING</code>: Recoverable issues (missing texture fallback).</li> <li><code>ERROR</code>: Exceptions and failures.</li> </ul> </li> </ul>"},{"location":"graphics/rendering/","title":"Rendering Pipeline","text":"<p>PyGuara employs a modern, backend-agnostic rendering architecture located in <code>pyguara.graphics</code>.</p>"},{"location":"graphics/rendering/#render-graph-architecture","title":"Render Graph Architecture","text":"<p>The engine uses a multi-pass render graph for compositing:</p> <pre><code>World Pass \u2192 Light Pass \u2192 Composite Pass \u2192 Post-Process Pass \u2192 Final Pass \u2192 UI\n</code></pre>"},{"location":"graphics/rendering/#render-passes","title":"Render Passes","text":"Pass Description WorldPass Renders sprites/geometry to a world framebuffer LightPass Renders dynamic lights with additive blending to a light map CompositePass Multiplies world \u00d7 lightmap for the final lit scene PostProcessPass Applies screen-space effects (bloom, vignette) FinalPass Blits the composed result to the screen"},{"location":"graphics/rendering/#framebuffer-management","title":"Framebuffer Management","text":"<p>The <code>FramebufferManager</code> handles FBO lifecycle: - Automatic creation on first request - Resize handling when window dimensions change - Proper cleanup on shutdown</p>"},{"location":"graphics/rendering/#core-pipeline","title":"Core Pipeline","text":"<p>The rendering process within each pass follows these stages:</p> <ol> <li>Submission: Entities submit <code>Renderable</code> items to the <code>RenderSystem</code>.</li> <li>Queueing: Items are stored in a <code>RenderQueue</code>.</li> <li>Sorting: The queue is sorted by Layer, Material, and Z-Index.</li> <li>Batching: The <code>Batcher</code> groups compatible draw calls (same material) into <code>RenderBatch</code> objects.</li> <li>Execution: The backend (e.g., <code>ModernGLRenderer</code>) executes the batches.</li> </ol>"},{"location":"graphics/rendering/#material-system","title":"Material System","text":"<p>Materials combine shader, texture, and uniforms:</p> <pre><code>from pyguara.graphics.materials import Material, Shader\n\n# Custom material with grayscale shader\ngrayscale_shader = Shader(ctx, vert_src, frag_src)\nmaterial = Material(\n    shader=grayscale_shader,\n    texture=my_texture,\n    uniforms={\"intensity\": 0.8}\n)\n\n# Assign to sprite\nsprite.material = material\n</code></pre> <p>Sprites without explicit materials use the default sprite material automatically.</p>"},{"location":"graphics/rendering/#2d-lighting","title":"2D Lighting","text":"<p>Dynamic lighting uses light components and a compositing pass:</p> <pre><code>from pyguara.graphics.lighting import LightSource, AmbientLight\n\n# Point light\nentity.add_component(LightSource(\n    color=Color(255, 200, 100),\n    radius=150.0,\n    intensity=1.2,\n    falloff=2.0  # Quadratic falloff\n))\n\n# Global ambient\nambient_entity.add_component(AmbientLight(\n    color=Color(30, 30, 50),\n    intensity=0.3\n))\n</code></pre> <p>The light pass renders all lights additively, then the composite pass multiplies world \u00d7 lightmap.</p>"},{"location":"graphics/rendering/#post-processing","title":"Post-Processing","text":"<p>Screen-space effects are chained via <code>PostProcessStack</code>:</p> <pre><code>from pyguara.graphics.vfx import PostProcessStack, BloomEffect, VignetteEffect\n\nstack = PostProcessStack(ctx, width, height)\nstack.add_effect(BloomEffect(ctx, threshold=0.8, intensity=0.5))\nstack.add_effect(VignetteEffect(ctx, radius=0.7, softness=0.4))\n</code></pre> <p>Effects can be enabled/disabled at runtime via <code>effect.enabled = False</code>.</p>"},{"location":"graphics/rendering/#components","title":"Components","text":""},{"location":"graphics/rendering/#camera2d","title":"Camera2D","text":"<p>Handles Coordinate Transformation (World Space &lt;-&gt; Screen Space). Supports Zoom, Rotation, and Panning.</p>"},{"location":"graphics/rendering/#viewport","title":"Viewport","text":"<p>Defines the drawable region on the screen. Used for: - Split-screen multiplayer. - Minimaps. - Aspect ratio enforcement (Letterboxing).</p>"},{"location":"graphics/rendering/#geometry","title":"Geometry","text":"<p>Procedural shapes (<code>Box</code>, <code>Circle</code>) that lazy-generate their textures. This allows them to be batched alongside standard sprites.</p>"},{"location":"graphics/rendering/#backends","title":"Backends","text":"<p>The engine uses the <code>IRenderer</code> protocol, allowing for different implementations:</p> <ul> <li>ModernGLRenderer (Recommended): GPU-accelerated OpenGL 3.3+ with hardware instancing. Supports all advanced features (lighting, post-processing).</li> <li>PygameBackend: CPU-based <code>pygame-ce</code> rendering. Uses stub implementations for advanced features (renders fully lit, no post-processing).</li> <li>HeadlessBackend: Discards draw calls. Useful for CI/CD and server-side simulation.</li> </ul>"},{"location":"graphics/rendering/#graceful-degradation","title":"Graceful Degradation","text":"<p>When using Pygame backend, advanced graphics features gracefully degrade:</p> Feature ModernGL Pygame Sprite rendering Hardware instanced Software blitting Lighting Dynamic light maps Fully lit (no shadows) Post-processing Bloom, vignette, etc. Pass-through (no effects) Materials Custom shaders Default only <p>Game code using these features runs unchanged on Pygame - stubs accept the API calls but skip the GPU operations.</p>"},{"location":"graphics/rendering/#ui-system","title":"UI System","text":"<p>The UI system (<code>pyguara.ui</code>) is immediate-mode friendly but retains state via an Object-Oriented widget tree.</p>"},{"location":"graphics/rendering/#architecture","title":"Architecture","text":"<ul> <li>UIManager: Routes input events (<code>OnMouseEvent</code>) to widgets.</li> <li>UIElement: Base class for all widgets (<code>Button</code>, <code>Panel</code>, <code>Label</code>).</li> <li>Layouts: <code>BoxContainer</code> handles automatic positioning (Vertical/Horizontal).</li> <li>Theme: A centralized <code>UITheme</code> controls colors and spacing.</li> </ul>"},{"location":"graphics/rendering/#integration","title":"Integration","text":"<p>The UI is rendered via the <code>UIRenderer</code> protocol, allowing it to sit on top of the main game render pass.</p>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/","title":"Architecture &amp; Style Guide","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#1-design-principles","title":"1. Design Principles","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#11-solid-compliance","title":"1.1. SOLID Compliance","text":"<ul> <li>S - Single Responsibility: Each class has ONE reason to change</li> <li>O - Open/Closed: Extend via protocols, not modification</li> <li>L - Liskov Substitution: Subtypes must be substitutable</li> <li>I - Interface Segregation: Prefer small, focused protocols</li> <li>D - Dependency Inversion: Depend on abstractions (protocols)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#12-pyguara-specific-patterns","title":"1.2. PyGuara-Specific Patterns","text":"<p>DO:</p> <ul> <li>\u2705 Use <code>Protocol</code> for all interfaces</li> <li>\u2705 Use <code>dataclass</code> for DTOs and components</li> <li>\u2705 Use type hints for ALL public APIs</li> <li>\u2705 Use DI container for cross-cutting concerns</li> <li>\u2705 Use events for decoupled communication</li> <li>\u2705 Use generators for large result sets</li> <li>\u2705 Use context managers for resource management</li> </ul> <p>DON'T:</p> <ul> <li>\u274c Don't use inheritance for behavior sharing (use composition)</li> <li>\u274c Don't put logic in components (data only)</li> <li>\u274c Don't import pygame outside <code>backends/</code> directory</li> <li>\u274c Don't use singletons (use DI instead)</li> <li>\u274c Don't use global state (except unavoidable like pygame)</li> <li>\u274c Don't use <code>print()</code> (use <code>logging</code>)</li> <li>\u274c Don't use string-based event types (use enums or classes)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#2-code-style-standards","title":"2. Code Style Standards","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#21-formatting-enforced-by-ruff","title":"2.1. Formatting (Enforced by Ruff)","text":"<pre><code># Line length: 88 characters (Black style)\n# Quotes: Double quotes for strings\n# Indentation: 4 spaces (no tabs)\n# Imports: Sorted (isort), grouped (stdlib, third-party, local)\n# Trailing commas: Yes (in multiline collections)\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#22-naming-conventions","title":"2.2. Naming Conventions","text":"<pre><code># Classes: PascalCase\nclass EntityManager: ...\n\n# Functions/Methods: snake_case\ndef get_entities_with(...): ...\n\n# Constants: UPPER_SNAKE_CASE\nMAX_ENTITIES = 10000\n\n# Private members: Leading underscore\nself._internal_cache = {}\n\n# Type variables: Single capital letter or PascalCase with T suffix\nT = TypeVar(\"T\")\nComponentT = TypeVar(\"ComponentT\", bound=Component)\n\n# Protocols: I prefix for interfaces (optional but recommended)\nclass IRenderer(Protocol): ...\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#23-type-annotations","title":"2.3. Type Annotations","text":"<pre><code># Always annotate function signatures\ndef create_entity(self, entity_id: Optional[str] = None) -&gt; Entity:\n    ...\n\n# Always annotate class attributes\nclass Component:\n    entity: Optional[Entity]\n\n# Use NewType for domain-specific types\nEntityID = NewType(\"EntityID\", str)\n\n# Use Protocol for structural typing\nclass Renderable(Protocol):\n    @property\n    def position(self) -&gt; Vector2: ...\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#24-docstring-format-google-style","title":"2.4. Docstring Format (Google Style)","text":"<pre><code>def complex_function(param1: int, param2: str) -&gt; dict[str, Any]:\n    \"\"\"Brief one-line summary.\n\n    Longer description if needed. Explain the \"why\" not the \"what\".\n    The \"what\" should be obvious from the code.\n\n    Args:\n        param1: Description of param1.\n        param2: Description of param2.\n\n    Returns:\n        A dictionary containing the results. Structure described here.\n\n    Raises:\n        ValueError: When param1 is negative.\n        KeyError: When param2 not in valid set.\n\n    Example:\n        &gt;&gt;&gt; result = complex_function(42, \"test\")\n        &gt;&gt;&gt; assert \"key\" in result\n    \"\"\"\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#3-architectural-patterns","title":"3. Architectural Patterns","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#31-component-definition","title":"3.1. Component Definition","text":"<pre><code>from dataclasses import dataclass\nfrom pyguara.ecs.component import BaseComponent\nfrom pyguara.common.types import Vector2\n\n@dataclass\nclass Transform(BaseComponent):\n    \"\"\"World space position and orientation.\n\n    This component should be present on all visible entities.\n    \"\"\"\n    position: Vector2 = Vector2(0, 0)\n    rotation: float = 0.0  # degrees\n    scale: Vector2 = Vector2(1, 1)\n\n    # NO METHODS (data only)\n    # Logic goes in Systems, not Components\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#32-system-definition","title":"3.2. System Definition","text":"<pre><code>from pyguara.ecs.manager import EntityManager\nfrom pyguara.common.components import Transform\nfrom pyguara.physics.components import RigidBody\n\nclass PhysicsSystem:\n    \"\"\"Synchronizes physics engine with ECS transform components.\n\n    Runs during the physics update phase, before rendering.\n    \"\"\"\n\n    def __init__(self, entity_manager: EntityManager, physics_engine: IPhysicsEngine):\n        self._entities = entity_manager\n        self._physics = physics_engine\n\n    def update(self, dt: float) -&gt; None:\n        \"\"\"Update all physics-enabled entities.\"\"\"\n        for entity in self._entities.get_entities_with(Transform, RigidBody):\n            transform = entity.get_component(Transform)\n            rigidbody = entity.get_component(RigidBody)\n\n            # Sync physics -&gt; ECS (for dynamic bodies)\n            if rigidbody.body_type == BodyType.DYNAMIC:\n                physics_body = self._physics.get_body(entity.id)\n                transform.position = physics_body.position\n                transform.rotation = physics_body.rotation\n            # Sync ECS -&gt; physics (for kinematic bodies)\n            else:\n                physics_body = self._physics.get_body(entity.id)\n                physics_body.position = transform.position\n                physics_body.rotation = transform.rotation\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#33-service-registration","title":"3.3. Service Registration","text":"<pre><code># In bootstrap.py or scene setup\ndef _setup_container() -&gt; DIContainer:\n    container = DIContainer()\n\n    # Singletons: Shared app-wide state\n    container.register_singleton(EventDispatcher, EventDispatcher)\n    container.register_singleton(ResourceManager, ResourceManager)\n\n    # Transient: New instance every request\n    container.register_transient(ParticleEmitter, ParticleEmitter)\n\n    # Scoped: Shared within a scene/scope\n    container.register_scoped(PhysicsSystem, PhysicsSystem)\n\n    return container\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#34-event-definition-and-usage","title":"3.4. Event Definition and Usage","text":"<pre><code>from dataclasses import dataclass, field\nfrom time import time\nfrom typing import Any\n\n@dataclass\nclass EntityDiedEvent:\n    \"\"\"Fired when an entity's health reaches zero.\n\n    Subscribers can use this to trigger death animations,\n    drop loot, update score, etc.\n    \"\"\"\n    entity_id: str\n    damage_source: Optional[str] = None\n    timestamp: float = field(default_factory=time)\n    source: Any = None  # The system that created the event\n\n# Usage\ndispatcher.subscribe(EntityDiedEvent, self._on_entity_died)\n\ndef _on_entity_died(self, event: EntityDiedEvent) -&gt; None:\n    print(f\"Entity {event.entity_id} died from {event.damage_source}\")\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#4-file-organization","title":"4. File Organization","text":"<pre><code>pyguara/\n\u251c\u2500\u2500 subsystem_name/\n\u2502   \u251c\u2500\u2500 __init__.py          # Public API exports\n\u2502   \u251c\u2500\u2500 protocols.py         # Interfaces (I* classes)\n\u2502   \u251c\u2500\u2500 types.py             # DTOs, Enums, TypeAliases\n\u2502   \u251c\u2500\u2500 exceptions.py        # Custom exceptions\n\u2502   \u251c\u2500\u2500 manager.py           # Main coordinator class\n\u2502   \u251c\u2500\u2500 components/          # If ECS-related\n\u2502   \u2502   \u251c\u2500\u2500 foo.py\n\u2502   \u2502   \u2514\u2500\u2500 bar.py\n\u2502   \u2514\u2500\u2500 backends/            # If hardware-abstracted\n\u2502       \u251c\u2500\u2500 pygame_impl.py\n\u2502       \u2514\u2500\u2500 headless_impl.py\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_subsystem_name.py\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#5-error-handling-strategy","title":"5. Error Handling Strategy","text":"<pre><code># Use specific exceptions\nfrom pyguara.subsystem.exceptions import SubsystemException\n\nclass EntityNotFoundException(SubsystemException):\n    \"\"\"Raised when entity lookup fails.\"\"\"\n    pass\n\n# Always provide context\nraise EntityNotFoundException(\n    f\"Entity '{entity_id}' not found in manager. \"\n    f\"Available entities: {list(self._entities.keys())[:5]}...\"\n)\n\n# Log before raising (for async/event contexts)\nlogger.error(f\"Failed to process event: {event}\", exc_info=True)\nraise\n\n# Use early returns\ndef process(self, entity: Entity) -&gt; None:\n    if not entity.has_component(Transform):\n        logger.warning(f\"Entity {entity.id} missing Transform, skipping\")\n        return\n\n    # Main logic here\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#6-repository-policies","title":"6. Repository Policies","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#61-branch-strategy","title":"6.1 Branch Strategy","text":"<pre><code>main (protected)\n  \u251c\u2500\u2500 develop (integration branch)\n  \u2502   \u251c\u2500\u2500 feature/P0-001-component-removal-tracking\n  \u2502   \u251c\u2500\u2500 feature/audio-system-implementation\n  \u2502   \u251c\u2500\u2500 bugfix/resource-memory-leak\n  \u2502   \u2514\u2500\u2500 docs/api-reference-sphinx\n  \u2514\u2500\u2500 release/v0.2.0-beta\n</code></pre> <p>Branch Naming:</p> <ul> <li><code>feature/</code> - New features</li> <li><code>bugfix/</code> - Bug fixes</li> <li><code>hotfix/</code> - Critical production fixes</li> <li><code>docs/</code> - Documentation only</li> <li><code>refactor/</code> - Code refactoring</li> <li><code>test/</code> - Test additions/improvements</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#62-commit-message-format","title":"6.2 Commit Message Format","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Formatting, no code change</li> <li><code>refactor</code>: Code restructuring</li> <li><code>perf</code>: Performance improvement</li> <li><code>test</code>: Adding tests</li> <li><code>chore</code>: Build process, tooling</li> </ul> <p>Example:</p> <pre><code>feat(input): add gamepad support with SDL2 backend\n\nImplements Xbox and PlayStation controller support using\npygame's joystick API wrapped in our input abstraction.\n\n- Added GamepadButton and GamepadAxis enums\n- Created JoystickBackend protocol\n- Implemented SDL2JoystickBackend\n- Added input action mapping for buttons\n\nCloses #42\nRelates to P0-006\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#63-pull-request-process","title":"6.3 Pull Request Process","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#631-pr-template","title":"6.3.1 PR Template","text":"<pre><code>## Description\nBrief summary of changes\n\n## Type of Change\n- [ ] Bug fix (non-breaking change which fixes an issue)\n- [ ] New feature (non-breaking change which adds functionality)\n- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)\n- [ ] Documentation update\n\n## Related Issues\nCloses #XXX\nRelates to #YYY\n\n## Testing\n- [ ] Unit tests added/updated\n- [ ] Integration tests added/updated\n- [ ] Manual testing performed\n- [ ] Performance impact assessed\n\n## Checklist\n- [ ] Code follows style guidelines (ruff check passes)\n- [ ] Type hints complete (mypy passes)\n- [ ] Docstrings added for public APIs\n- [ ] Tests pass locally\n- [ ] No breaking changes OR migration guide provided\n- [ ] Documentation updated\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#632-review-requirements","title":"6.3.2 Review Requirements","text":"<ul> <li>Minimum Reviewers: 1 (for large changes: 2)</li> <li>Required Checks:</li> <li>\u2705 CI tests pass</li> <li>\u2705 Code coverage doesn't decrease</li> <li>\u2705 Ruff and mypy checks pass</li> <li>\u2705 No merge conflicts</li> <li>Approval Required: Yes (from code owner or maintainer)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#64-issue-management","title":"6.4 Issue Management","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#641-issue-labels","title":"6.4.1 Issue Labels","text":"<pre><code>Priority:\n- P0-critical: Blocking release\n- P1-high: Important but not blocking\n- P2-medium: Nice to have\n- P3-low: Future consideration\n\nType:\n- bug: Something isn't working\n- enhancement: New feature request\n- documentation: Docs improvement\n- performance: Performance issue\n- technical-debt: Refactoring needed\n\nStatus:\n- needs-triage: Awaiting review\n- accepted: Approved for implementation\n- in-progress: Being worked on\n- blocked: Waiting on dependency\n- wontfix: Closed without action\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#642-issue-template","title":"6.4.2 Issue Template","text":"<pre><code>**Describe the Issue**\nClear description of the problem or request\n\n**Expected Behavior**\nWhat should happen\n\n**Actual Behavior**\nWhat actually happens\n\n**Steps to Reproduce**\n1. Step 1\n2. Step 2\n3. ...\n\n**Environment**\n- PyGuara Version: X.Y.Z\n- Python Version: 3.12.X\n- OS: Linux/Windows/Mac\n- pygame-ce Version: X.Y.Z\n\n**Additional Context**\nScreenshots, code snippets, error traces\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#65-testing-requirements","title":"6.5 Testing Requirements","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#651-test-coverage-targets","title":"6.5.1 Test Coverage Targets","text":"<ul> <li>Overall: \u2265 80%</li> <li>Core Systems (ECS, DI, Events): \u2265 90%</li> <li>New Features: \u2265 85%</li> <li>Bug Fixes: 100% (must include regression test)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#652-test-structure","title":"6.5.2 Test Structure","text":"<pre><code># tests/test_subsystem.py\nimport pytest\nfrom pyguara.subsystem import Thing\n\nclass TestThing:\n    \"\"\"Test suite for Thing class.\"\"\"\n\n    def test_creation(self):\n        \"\"\"Verify Thing can be created with defaults.\"\"\"\n        thing = Thing()\n        assert thing is not None\n\n    def test_method_with_valid_input(self):\n        \"\"\"Test method behavior with valid input.\"\"\"\n        thing = Thing()\n        result = thing.method(valid_input)\n        assert result == expected\n\n    def test_method_raises_on_invalid_input(self):\n        \"\"\"Test method raises appropriate exception.\"\"\"\n        thing = Thing()\n        with pytest.raises(ValueError, match=\"expected pattern\"):\n            thing.method(invalid_input)\n\n    @pytest.mark.performance\n    def test_performance_at_scale(self):\n        \"\"\"Verify performance with large dataset.\"\"\"\n        thing = Thing()\n        # Benchmark code\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#653-cicd-pipeline","title":"6.5.3 CI/CD Pipeline","text":"<pre><code># .github/workflows/ci.yml structure\nJobs:\n  - lint: Run ruff check\n  - typecheck: Run mypy\n  - test-unit: Run pytest (unit tests)\n  - test-integration: Run pytest (integration tests)\n  - test-performance: Run pytest (benchmark tests)\n  - coverage: Generate and upload coverage report\n  - build: Verify package builds\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#66-documentation-standards","title":"6.6 Documentation Standards","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#661-required-documentation-for-features","title":"6.6.1 Required Documentation for Features","text":"<ol> <li>API Reference: Auto-generated from docstrings</li> <li>Tutorial: Step-by-step guide for common use case</li> <li>Example: Working code snippet in examples/</li> <li>Architecture Decision Record: For significant design choices</li> </ol>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#662-adr-template","title":"6.6.2 ADR Template","text":"<pre><code># ADR-XXX: Title\n\n## Status\nProposed | Accepted | Deprecated | Superseded by ADR-YYY\n\n## Context\nWhat is the issue we're facing?\n\n## Decision\nWhat did we decide?\n\n## Consequences\nWhat are the trade-offs?\n\n### Positive\n- Benefit 1\n- Benefit 2\n\n### Negative\n- Cost 1\n- Cost 2\n\n## Alternatives Considered\n- Alternative 1: Why rejected\n- Alternative 2: Why rejected\n</code></pre>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#7-quality-gates-acceptance-criteria","title":"7. Quality Gates &amp; Acceptance Criteria","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#71-definition-of-done-dod","title":"7.1 Definition of Done (DoD)","text":"<p>A feature/fix is considered \"Done\" when ALL of the following are true:</p>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#code-quality","title":"Code Quality","text":"<ul> <li>[ ] Code follows style guide (ruff check passes)</li> <li>[ ] Type hints complete (mypy passes with no errors)</li> <li>[ ] No TODO/FIXME comments (unless tracked in issues)</li> <li>[ ] No commented-out code</li> <li>[ ] No print() statements (use logging)</li> <li>[ ] Docstrings added for all public APIs (Google style)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#testing","title":"Testing","text":"<ul> <li>[ ] Unit tests written (coverage \u2265 85% for new code)</li> <li>[ ] Integration tests added (if applicable)</li> <li>[ ] All tests pass locally</li> <li>[ ] CI pipeline green</li> <li>[ ] Performance impact assessed (benchmarks run)</li> <li>[ ] Manual testing completed (test plan documented)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#documentation","title":"Documentation","text":"<ul> <li>[ ] API reference updated (docstrings)</li> <li>[ ] Tutorial/guide written (for features)</li> <li>[ ] Example code added (if applicable)</li> <li>[ ] CHANGELOG.md updated</li> <li>[ ] Architecture decision recorded (for significant changes)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#review","title":"Review","text":"<ul> <li>[ ] Code reviewed and approved</li> <li>[ ] No unresolved review comments</li> <li>[ ] Breaking changes flagged and documented</li> <li>[ ] Migration guide provided (if breaking change)</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#integration","title":"Integration","text":"<ul> <li>[ ] Merged to develop branch</li> <li>[ ] No merge conflicts</li> <li>[ ] Build succeeds</li> <li>[ ] Integration tests pass</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#72-release-criteria","title":"7.2 Release Criteria","text":""},{"location":"guides/Archictecture%20%26%20Style%20Guide/#alpha-release-current","title":"Alpha Release (Current)","text":"<ul> <li>\u2705 Core systems functional</li> <li>\u2705 Basic example works</li> <li>\u26a0\ufe0f Known bugs acceptable</li> <li>\u26a0\ufe0f Documentation minimal</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#beta-release-target","title":"Beta Release (Target)","text":"<ul> <li>[ ] All P0 issues resolved</li> <li>[ ] All P1 issues resolved</li> <li>[ ] Test coverage \u2265 80%</li> <li>[ ] API stable (no breaking changes planned)</li> <li>[ ] 3+ complete example games</li> <li>[ ] Full API documentation</li> <li>[ ] Tutorial series complete</li> <li>[ ] Performance benchmarks published</li> <li>[ ] Community beta testing (2+ weeks)</li> <li>[ ] Critical bugs &lt; 5</li> <li>[ ] Known issues documented</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#10-release-future","title":"1.0 Release (Future)","text":"<ul> <li>[ ] All P0-P2 issues resolved</li> <li>[ ] Test coverage \u2265 90%</li> <li>[ ] Production games shipped</li> <li>[ ] Stability tested (1000+ hours gameplay)</li> <li>[ ] Plugin system mature</li> <li>[ ] Community contributions accepted</li> <li>[ ] Professional documentation</li> <li>[ ] Video tutorials available</li> <li>[ ] No critical or high-priority bugs</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#73-performance-benchmarks","title":"7.3 Performance Benchmarks","text":"<p>All releases must meet these minimum performance targets on reference hardware (mid-range laptop):</p> Benchmark Target Measurement Entity Creation 10,000/sec <code>benchmark_entity_creation()</code> Component Query 100,000/sec <code>benchmark_component_query()</code> Event Dispatch 50,000/sec <code>benchmark_event_dispatch()</code> Sprite Rendering 60 FPS @ 5000 sprites <code>benchmark_sprite_rendering()</code> Physics Simulation 60 FPS @ 1000 bodies <code>benchmark_physics()</code> Scene Load Time &lt; 1 second <code>benchmark_scene_load()</code> Memory Usage &lt; 500 MB @ 10k entities <code>benchmark_memory()</code> Asset Load &lt; 100ms per 1MB <code>benchmark_asset_loading()</code> <p>Reference Hardware:</p> <ul> <li>CPU: Intel i5-8250U or equivalent</li> <li>RAM: 8GB DDR4</li> <li>GPU: Integrated graphics</li> <li>OS: Ubuntu 22.04 LTS</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#74-security-checklist","title":"7.4 Security Checklist","text":"<p>For each release, verify:</p> <ul> <li>[ ] No secrets in codebase (API keys, passwords)</li> <li>[ ] User input sanitized (file paths, save data)</li> <li>[ ] No code execution from data files (unless sandboxed)</li> <li>[ ] Dependencies scanned for vulnerabilities</li> <li>[ ] Save files validated before loading</li> <li>[ ] Network code (future) uses encryption</li> <li>[ ] Error messages don't leak sensitive info</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#appendix-a-glossary","title":"Appendix A: Glossary","text":"<p>ECS: Entity-Component-System architecture pattern DI: Dependency Injection (IoC container) DoD: Definition of Done ADR: Architecture Decision Record HAL: Hardware Abstraction Layer P0/P1/P2/P3: Priority levels (0 = Critical, 3 = Low) SFX: Sound Effects UI: User Interface DX: Developer Experience</p>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#appendix-b-references","title":"Appendix B: References","text":"<ul> <li>PyGuara Repository</li> <li>Python Type Hints (PEP 484)</li> <li>Pygame Documentation</li> <li>Pymunk Documentation</li> <li>ECS FAQ</li> <li>Game Programming Patterns</li> </ul>"},{"location":"guides/Archictecture%20%26%20Style%20Guide/#document-history","title":"Document History","text":"Version Date Author Changes 1.0 2026-01-09 Wedeueis Braz Initial draft"},{"location":"guides/ONBOARDING/","title":"PyGuara Engine: Developer Onboarding Guide","text":"<p>Welcome to the PyGuara Engine! This guide provides an in-depth overview of the engine's architecture, systems, and design patterns. Its purpose is to help new developers understand how to use the engine effectively and consistently, embracing the core philosophies that make it powerful and maintainable.</p>"},{"location":"guides/ONBOARDING/#1-core-architecture-principles","title":"1. Core Architecture Principles","text":"<p>Before diving into individual systems, it's crucial to understand the three core principles that govern the entire engine. You will see these patterns everywhere.</p>"},{"location":"guides/ONBOARDING/#11-dependency-injection-di","title":"1.1. Dependency Injection (DI)","text":"<ul> <li>Architecture: The engine is built around a central DI Container (<code>pyguara/di/container.py</code>). At startup (<code>main.py</code>), systems and managers are \"registered\" with this container. When a class is created, the container automatically provides (injects) the dependencies it asks for in its <code>__init__</code> method.</li> <li>Design Pattern (Inversion of Control): Instead of a class creating its own dependencies (e.g., <code>self.resource_manager = ResourceManager()</code>), it declares them in its constructor (<code>def __init__(self, resource_manager: ResourceManager):</code>). This decouples the class from its dependencies, making the system modular, testable, and easier to manage.</li> <li> <p>How to Use: When creating a new <code>System</code> or <code>Manager</code>, simply add other registered systems you need as arguments to <code>__init__</code>. The DI container will handle the rest.</p> <p>```python</p> </li> </ul>"},{"location":"guides/ONBOARDING/#before-di-tightly-coupled","title":"Before DI: Tightly Coupled","text":"<p>class MySystem:     def init(self):         # Bad: This system is permanently tied to a specific resource manager         self.resource_manager = ResourceManager()</p>"},{"location":"guides/ONBOARDING/#after-di-decoupled-and-testable","title":"After DI: Decoupled and Testable","text":"<p>class MySystem:     def init(self, resource_manager: ResourceManager):         # Good: Receives any object that acts like a ResourceManager.         self.resource_manager = resource_manager ```</p>"},{"location":"guides/ONBOARDING/#12-backend-abstraction-hardware-abstraction-layer-hal","title":"1.2. Backend Abstraction (Hardware Abstraction Layer - HAL)","text":"<ul> <li>Architecture: Systems that interact with low-level hardware or external libraries (Graphics, Physics, Audio, Input) are split into two parts:<ol> <li>A high-level <code>Manager</code> or <code>System</code> that game code interacts with.</li> <li>A <code>protocol.py</code> file defining an interface (e.g., <code>IRenderer</code>, <code>IPhysicsEngine</code>).</li> <li>A <code>backends/</code> directory containing concrete implementations of that interface (e.g., <code>PygameRenderer</code>, <code>PymunkEngine</code>).</li> </ol> </li> <li>Design Pattern (Strategy/Bridge): This decouples the engine's logic from any specific library. The <code>PhysicsSystem</code> doesn't know about \"Pymunk\"; it only knows about the <code>IPhysicsEngine</code> interface. This allows backends to be swapped (e.g., from Pygame to a future OpenGL renderer) without rewriting any game logic.</li> <li>How to Use: Always code against the high-level <code>Manager</code> or <code>System</code> (e.g., <code>AudioManager</code>, <code>RenderSystem</code>). Never interact directly with a backend implementation.</li> </ul>"},{"location":"guides/ONBOARDING/#13-event-driven-communication","title":"1.3. Event-Driven Communication","text":"<ul> <li>Architecture: The engine uses a global <code>EventDispatcher</code> (<code>pyguara/events/dispatcher.py</code>) to allow systems to communicate without direct references to each other.</li> <li>Design Pattern (Observer/Pub-Sub): One system \"dispatches\" an event, and other systems can \"subscribe\" to that type of event.</li> <li> <p>How to Use: When a significant event occurs, dispatch an event instead of calling another system directly. For example, the <code>CollisionSystem</code> dispatches an <code>OnCollisionBegin</code> event; it does not know what a \"Player\" or \"ScoreSystem\" is. The <code>ScoreSystem</code> can then subscribe to <code>OnCollisionBegin</code> and update the score if needed.</p> <p>```python</p> </li> </ul>"},{"location":"guides/ONBOARDING/#in-your-systemscene-that-needs-to-react-to-events","title":"In your system/scene that needs to react to events","text":"<p>def init(self, event_dispatcher: EventDispatcher):     self.event_dispatcher = event_dispatcher     self.event_dispatcher.subscribe(OnCollisionBegin, self.on_collision)</p> <p>def on_collision(self, event: OnCollisionBegin):     print(f\"Collision between {event.entity_a} and {event.entity_b}!\") ```</p>"},{"location":"guides/ONBOARDING/#2-the-entity-component-system-ecs-framework","title":"2. The Entity-Component-System (ECS) Framework","text":"<ul> <li>Location: <code>pyguara/ecs/</code></li> <li>Architecture: PyGuara uses a high-performance ECS architecture.<ul> <li>Entity: A simple ID. It is not an object; it is just a number that \"owns\" a collection of components.</li> <li>Component: Pure data. A component is a <code>dataclass</code> that holds data, but no logic (e.g., <code>Transform</code>, <code>RigidBody</code>).</li> <li>System: Pure logic. A system contains all the logic that operates on entities possessing a certain set of components (e.g., <code>PhysicsSystem</code> operates on entities with <code>Transform</code> and <code>RigidBody</code>).</li> </ul> </li> <li>Design Pattern (Composition over Inheritance): Instead of creating a <code>Player</code> class that inherits from <code>GameObject</code>, you create an entity and compose it by adding components: <code>Transform</code>, <code>Sprite</code>, <code>PlayerInput</code>, <code>Health</code>.</li> </ul>"},{"location":"guides/ONBOARDING/#how-to-use","title":"How to Use","text":"<ol> <li> <p>Define Components: Create new <code>dataclass</code>es in a <code>components.py</code> file for your feature.</p> <p>```python from dataclasses import dataclass from pyguara.common.types import Vector2</p> <p>@dataclass class Transform:     position: Vector2 = field(default_factory=Vector2.zero)</p> <p>@dataclass class PlayerInput:     move_speed: float = 100.0 ```</p> </li> <li> <p>Create Systems: Create a class that operates on entities with those components.</p> <p>```python class PlayerMovementSystem:     def init(self, entity_manager: EntityManager):         self.entity_manager = entity_manager</p> <pre><code>def update(self, dt: float):\n    # Query for all entities that have BOTH Transform and PlayerInput\n    for entity in self.entity_manager.get_entities_with(Transform, PlayerInput):\n        transform = entity.get_component(Transform)\n        player_input = entity.get_component(PlayerInput)\n\n        # ... apply movement logic ...\n</code></pre> <p>```</p> </li> <li> <p>Create Entities: In your scene, get the <code>EntityManager</code> and create entities.</p> <p>```python</p> </li> </ol>"},{"location":"guides/ONBOARDING/#in-your-gameplayscenes-on_enter-method","title":"In your GameplayScene's on_enter method","text":"<p>player_entity = self.entity_manager.create_entity() self.entity_manager.add_component(player_entity, Transform(position=Vector2(100, 100))) self.entity_manager.add_component(player_entity, PlayerInput()) self.entity_manager.add_component(player_entity, Sprite(texture=...)) ```</p>"},{"location":"guides/ONBOARDING/#3-graphics-system","title":"3. Graphics System","text":"<ul> <li>Location: <code>pyguara/graphics/</code></li> <li>Architecture: A backend-agnostic, pipeline-based rendering system.<ul> <li>Protocols (<code>IRenderer</code>): Define the abstract drawing commands.</li> <li>Backend (<code>PygameRenderer</code>): Implements the drawing commands using Pygame.</li> <li>RenderSystem (<code>pipeline/render_system.py</code>): The main system that orchestrates the rendering process. It collects all <code>Renderable</code> objects, sorts them for 2D layering, batches them for performance, and sends them to the backend.</li> </ul> </li> <li>Features:<ul> <li>Sprite rendering with position, rotation, and scale.</li> <li>Layering and Z-sorting for correct 2D depth.</li> <li>High-performance sprite batching (<code>pygame.Surface.blits</code>).</li> <li>Camera and viewport support.</li> <li>Basic primitive drawing (rects, circles, lines) for debugging.</li> </ul> </li> <li> <p>How to Use:</p> <ol> <li>Create an entity with a <code>Transform</code> component and a <code>Sprite</code> component. The <code>Sprite</code> component holds the texture, layer, and other render-specific data.</li> <li>The <code>RenderSystem</code> (which is managed by the <code>SystemManager</code>) will automatically find and draw this entity each frame. You do not need to call a <code>draw</code> method yourself.</li> </ol> <p>```python from pyguara.common.components import Transform from pyguara.graphics.components import Sprite</p> </li> </ul>"},{"location":"guides/ONBOARDING/#in-a-scenes-on_enter-method","title":"In a scene's on_enter method","text":"<p>texture = self.resource_manager.load(\"sprites/my_sprite.png\", Texture) my_entity = self.entity_manager.create_entity() self.entity_manager.add_component(my_entity, Transform(position=Vector2(50, 50))) self.entity_manager.add_component(my_entity, Sprite(texture=texture, layer=10)) ```</p>"},{"location":"guides/ONBOARDING/#4-physics-system","title":"4. Physics System","text":"<ul> <li>Location: <code>pyguara/physics/</code></li> <li>Architecture: A backend-agnostic, three-part system.<ul> <li>Backend (<code>PymunkEngine</code>): Implements the <code>IPhysicsEngine</code> protocol using the Pymunk library. It does the heavy lifting.</li> <li>PhysicsSystem: The ECS system that synchronizes data between the game world (<code>Transform</code> components) and the physics world (<code>Pymunk.Body</code>).</li> <li>CollisionSystem: Receives callbacks from the backend and dispatches high-level <code>OnCollisionBegin</code>, <code>OnTriggerEnter</code>, etc., events.</li> </ul> </li> <li>Features:<ul> <li>Static, Kinematic, and Dynamic rigid bodies.</li> <li>Circle and Box colliders.</li> <li>Physics materials (friction, restitution).</li> <li>Triggers (non-solid colliders).</li> <li>A rich set of joints (Pin, Spring, Slider).</li> <li>Raycasting.</li> </ul> </li> <li> <p>How to Use:</p> <ol> <li>Add a <code>RigidBody</code> component to an entity to give it physics properties.</li> <li>Add a <code>Collider</code> component to give it a physical shape.</li> <li>The <code>PhysicsSystem</code> will automatically create the body in the Pymunk world.</li> <li>For dynamic bodies, the <code>PhysicsSystem</code> will update the entity's <code>Transform</code> component each frame based on the simulation.</li> </ol> <p>```python from pyguara.physics.components import RigidBody, Collider from pyguara.physics.types import BodyType, ShapeType</p> </li> </ul>"},{"location":"guides/ONBOARDING/#create-a-dynamic-falling-box","title":"Create a dynamic, falling box","text":"<p>box = self.entity_manager.create_entity() self.entity_manager.add_component(box, Transform()) self.entity_manager.add_component(box, RigidBody(body_type=BodyType.DYNAMIC)) self.entity_manager.add_component(box, Collider(shape_type=ShapeType.BOX, dimensions=[32, 32])) ```</p>"},{"location":"guides/ONBOARDING/#5-ui-system","title":"5. UI System","text":"<ul> <li>Location: <code>pyguara/ui/</code></li> <li>Architecture: A powerful, retained-mode, constraint-based UI framework.<ul> <li>UIManager: Manages the UI tree, processes input, and orchestrates rendering.</li> <li>UIElement: The base class for all UI components. Provides a state machine (normal, hover, pressed), event handling, and layout hooks.</li> <li>Components: A rich library of widgets (<code>Button</code>, <code>Panel</code>, <code>Slider</code>, etc.).</li> <li>Layout &amp; Constraints: A declarative system for positioning and sizing elements using anchors, margins, and percentages. This is the heart of the UI system's power.</li> <li>Theming: A centralized theme file (<code>theme.py</code>) defines colors, fonts, and styles, allowing for easy reskinning.</li> </ul> </li> <li>Features:<ul> <li>Full suite of standard UI widgets.</li> <li>Stateful components with automatic state changes on interaction.</li> <li>Declarative, responsive layout system that avoids manual pixel positioning.</li> <li>Centralized styling and theming.</li> </ul> </li> <li> <p>How to Use:</p> <ol> <li>Get the <code>UIManager</code> from the DI container.</li> <li>Instantiate UI components, setting their text, size, etc.</li> <li>Define layout rules using <code>LayoutConstraints</code>.</li> <li>Assign callbacks to interaction events like <code>on_click</code>.</li> <li>Add the element to the <code>UIManager</code>.</li> </ol> <p>```python from pyguara.ui.components import Button from pyguara.ui.constraints import create_centered_constraints</p> <p>def on_my_button_click(button: Button):     print(\"Button clicked!\")</p> </li> </ul>"},{"location":"guides/ONBOARDING/#in-a-scenes-on_enter-method_1","title":"In a scene's on_enter method","text":"<p>ui_manager = self.container.get(UIManager)</p> <p>my_button = Button(text=\"Click Me\", position=Vector2(0,0)) # Position is controlled by layout my_button.constraints = create_centered_constraints(width_percent=0.2, height_percent=0.1) my_button.on_click = on_my_button_click</p> <p>ui_manager.add_element(my_button) ```</p>"},{"location":"guides/ONBOARDING/#6-ai-system","title":"6. AI System","text":"<ul> <li>Location: <code>pyguara/ai/</code></li> <li>Architecture: A suite of high-level AI tools integrated into the ECS.<ul> <li>AISystem: The main ECS system that ticks the AI components.</li> <li>AIComponent: A component that holds the AI logic for an entity (e.g., an FSM or a Behavior Tree instance).</li> </ul> </li> <li>Features:<ul> <li>Finite State Machines (FSMs): For simple, state-based AI.</li> <li>Behavior Trees (BTs): A professional-grade BT implementation for complex, hierarchical AI logic. Includes all standard node types (Sequence, Selector, Parallel, Decorators).</li> <li>Steering Behaviors: For dynamic movement (seek, flee, arrive).</li> <li>Pathfinding: A* pathfinding on a navigation mesh.</li> </ul> </li> <li> <p>How to Use (Behavior Tree):</p> <ol> <li>Define simple functions that will act as your leaf nodes.</li> <li>Compose these functions into a tree using <code>SequenceNode</code>, <code>SelectorNode</code>, etc.</li> <li>Create a <code>BehaviorTree</code> instance with your root node.</li> <li>Add an <code>AIComponent</code> to your entity and assign the tree to it.</li> </ol> <p>```python from pyguara.ai.behavior_tree import BehaviorTree, ActionNode, SequenceNode, SelectorNode, NodeStatus</p> <p>def find_player(context) -&gt; NodeStatus:     # ... logic to find player ...     if found:         context.blackboard['player_pos'] = player_position         return NodeStatus.SUCCESS     return NodeStatus.FAILURE</p> <p>def move_towards_player(context) -&gt; NodeStatus:     # ... logic to move towards context.blackboard['player_pos'] ...     if close_enough:         return NodeStatus.SUCCESS     return NodeStatus.RUNNING # Still moving</p> </li> </ul>"},{"location":"guides/ONBOARDING/#in-your-scene","title":"In your scene","text":"<p>attack_sequence = SequenceNode([find_player, move_towards_player]) patrol_action = ActionNode(...) root_node = SelectorNode([attack_sequence, patrol_action])</p> <p>tree = BehaviorTree(root=root_node) ai_comp = AIComponent() ai_comp.behavior_tree = tree # The AISystem will tick this</p> <p>my_enemy = self.entity_manager.create_entity() self.entity_manager.add_component(my_enemy, ai_comp) ```</p>"},{"location":"guides/ONBOARDING/#7-support-systems-quick-reference","title":"7. Support Systems Quick Reference","text":"<p>The following systems provide critical infrastructure for the rest of the engine. They follow the same high-quality design patterns.</p> <ul> <li>Animation (<code>pyguara/animation</code>): A powerful tweening engine for animating any numeric property over time with easing functions. Use <code>TweenManager</code> to create and manage <code>Tween</code> objects for UI effects, camera movement, etc.</li> <li>Input (<code>pyguara/input</code>): A robust action-based input mapping system. Use the <code>InputManager</code> to <code>register_action</code> (e.g., \"jump\") and <code>bind_input</code> (e.g., spacebar to \"jump\"). Game code should listen for <code>OnActionEvent</code> and check the <code>action_name</code>, not for raw key presses.</li> <li>Persistence (<code>pyguara/persistence</code>): A complete save/load system. Use the <code>PersistenceManager</code>'s <code>save_data</code> and <code>load_data</code> methods. It automatically handles serialization, data integrity checksums, and versioning.</li> <li>Resources (<code>pyguara/resources</code>): A professional-grade asset management pipeline. Use the <code>ResourceManager</code> to <code>load</code> assets. It handles caching, type-safe loading, and automatic memory management via reference counting. The <code>index_directory</code> feature allows loading by simple name (e.g., <code>\"player_idle\"</code>).</li> <li>Scripting (<code>pyguara/scripting</code>): A coroutine system for writing sequential, time-based logic without complex state machines. Write a generator function and use <code>yield</code> with helpers like <code>wait_for_seconds()</code> and <code>wait_until()</code>. Start it with <code>CoroutineManager.start_coroutine()</code>.</li> <li>Editor (<code>pyguara/editor</code>): A powerful, live, in-game editor built with Dear ImGui. Press F12 to toggle. Provides a scene hierarchy, a component inspector that automatically reflects <code>dataclass</code> components, and scene saving/loading.</li> <li>Config (<code>pyguara/config</code>): A centralized manager for <code>game_config.json</code>. It provides type-safe access to settings via the <code>GameConfig</code> dataclass, validates data on load, and fires events on changes.</li> <li>Error (<code>pyguara/error</code>): A structured exception hierarchy. All engine errors inherit from <code>EngineException</code> and carry a rich <code>ErrorContext</code> object for easier debugging.</li> <li>Log (<code>pyguara/log</code>): A clean configuration wrapper around Python's standard <code>logging</code> module. Use <code>setup_logging</code> once at startup, then get a logger in any module with <code>get_logger(__name__)</code>.</li> <li>Systems (<code>pyguara/systems</code>): The <code>SystemManager</code> orchestrates the execution order of all ECS systems based on a priority number. Systems are registered with the manager, which then calls their <code>update</code> method in the correct order each frame.</li> <li>Tools (<code>pyguara/tools</code>): The infrastructure for managing developer tools like the Editor. The <code>ToolManager</code> handles visibility, input routing, and shortcuts for all registered tools.</li> </ul> <p>This guide should provide a solid foundation for getting started with the PyGuara Engine. By understanding and using these core patterns, you can build complex, maintainable, and high-performance games.</p>"},{"location":"guides/PROJECT_STRUCTURE/","title":"PyGuara Project Structure Guide","text":"<p>PyGuara is not a typical scripting framework; it is an ECS (Entity Component System) engine built around Dependency Injection (DI). This architecture requires a strict separation of concerns: Data (Components), Logic (Systems), and Composition (Scenes/Prefabs).</p> <p>To maintain scalability and performance, developers should adhere to the following project structure.</p>"},{"location":"guides/PROJECT_STRUCTURE/#1-directory-layout","title":"1. Directory Layout","text":"<p>The root directory acts as a workspace. Your actual game code resides strictly within <code>src/</code>.</p> <pre><code>my_game_project/\n\u251c\u2500\u2500 assets/                  # Runtime resources (Must be strictly organized)\n\u2502   \u251c\u2500\u2500 textures/            # .png, .jpg\n\u2502   \u251c\u2500\u2500 audio/               # .wav, .ogg\n\u2502   \u251c\u2500\u2500 fonts/               # .ttf, .otf\n\u2502   \u2514\u2500\u2500 data/                # .json, .yaml (Game balance data, dialogue)\n\u251c\u2500\u2500 config/                  # Configuration files\n\u2502   \u251c\u2500\u2500 game.json            # Main config (Resolution, Inputs, Debug flags)\n\u2502   \u2514\u2500\u2500 logging.json         # Logger configuration\n\u251c\u2500\u2500 src/                     # Source code root\n\u2502   \u2514\u2500\u2500 my_game/             # Your game package (Rename this to your game name)\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 main.py          # Application Entry Point\n\u2502       \u251c\u2500\u2500 bootstrap.py     # DI Container &amp; System Registration (CRITICAL)\n\u2502       \u251c\u2500\u2500 components/      # Pure Data (Dataclasses only)\n\u2502       \u251c\u2500\u2500 systems/         # Game Logic &amp; Behavior\n\u2502       \u251c\u2500\u2500 prefabs/         # Entity Factories (Blueprints)\n\u2502       \u251c\u2500\u2500 scenes/          # Scene Definitions (Composition Roots)\n\u2502       \u2514\u2500\u2500 ui/              # UI Widgets and Layouts\n\u251c\u2500\u2500 tests/                   # Unit and Integration tests\n\u251c\u2500\u2500 pyproject.toml           # Dependencies (uv/poetry/pip)\n\u2514\u2500\u2500 README.md\n\n</code></pre>"},{"location":"guides/PROJECT_STRUCTURE/#2-core-modules-breakdown","title":"2. Core Modules Breakdown","text":""},{"location":"guides/PROJECT_STRUCTURE/#a-the-bootstrap-srcmy_gamebootstrappy","title":"A. The Bootstrap (<code>src/my_game/bootstrap.py</code>)","text":"<p>Unlike simpler frameworks where you write logic in a global loop, PyGuara requires systems to be registered in a Dependency Injection Container.</p> <ul> <li>Role: configure the <code>DIContainer</code> with your game-specific systems.</li> <li>Best Practice: Never register systems inside <code>main.py</code>. Keep the entry point clean.</li> </ul> <pre><code># bootstrap.py\nfrom pyguara.application.bootstrap import create_application_container\nfrom my_game.systems.combat import CombatSystem\nfrom my_game.systems.ai import AiSystem\n\ndef configure_game_container():\n    # 1. Initialize Core Engine\n    container = create_application_container()\n\n    # 2. Register Game Systems (Singletons persist effectively)\n    container.register_singleton(CombatSystem, CombatSystem)\n    container.register_singleton(AiSystem, AiSystem)\n\n    return container\n\n</code></pre>"},{"location":"guides/PROJECT_STRUCTURE/#b-components-srcmy_gamecomponents","title":"B. Components (<code>src/my_game/components/</code>)","text":"<p>This directory contains pure data.</p> <ul> <li>Rule: Components must be Python <code>@dataclass</code>.</li> <li>Rule: Components must not contain game logic (methods like <code>update()</code> or <code>shoot()</code>).</li> <li>Rule: Serializable fields only (ints, floats, strings, bools, Vector2).</li> </ul> <pre><code># components/gameplay.py\nfrom dataclasses import dataclass\n\n@dataclass\nclass Health:\n    current: float\n    max: float\n\n</code></pre>"},{"location":"guides/PROJECT_STRUCTURE/#c-systems-srcmy_gamesystems","title":"C. Systems (<code>src/my_game/systems/</code>)","text":"<p>This is the \"Brain\" of the game. Systems retrieve data, process it, and write it back.</p> <ul> <li>Rule: Systems are injected with <code>EntityManager</code> or <code>EventDispatcher</code>.</li> <li>Rule: Logic goes here. If an entity takes damage, the <code>CombatSystem</code> calculates it, not the Entity class.</li> </ul> <pre><code># systems/combat.py\nclass CombatSystem:\n    def __init__(self, entity_manager: EntityManager):\n        self._em = entity_manager\n\n    def update(self, dt: float):\n        # Query entities that have Health\n        for entity in self._em.get_entities_with(Health):\n            pass # Logic here\n\n</code></pre>"},{"location":"guides/PROJECT_STRUCTURE/#d-prefabs-srcmy_gameprefabs","title":"D. Prefabs (<code>src/my_game/prefabs/</code>)","text":"<p>Since PyGuara creates entities via code, \"Prefabs\" are factory functions that assemble an entity from multiple components.</p> <ul> <li>Role: Centralize entity creation. Don't manually <code>add_component</code> inside your scenes; call a prefab instead.</li> </ul> <pre><code># prefabs/player.py\ndef create_player(manager: EntityManager, pos: Vector2):\n    e = manager.create_entity(\"hero\")\n    e.add_component(Transform(position=pos))\n    e.add_component(Health(100, 100))\n    e.add_component(Sprite(texture=\"hero.png\"))\n    return e\n\n</code></pre>"},{"location":"guides/PROJECT_STRUCTURE/#e-scenes-srcmy_gamescenes","title":"E. Scenes (<code>src/my_game/scenes/</code>)","text":"<p>Scenes are the Composition Roots. They do not contain heavy logic. Their job is to:</p> <ol> <li>Resolve Systems from the Container.</li> <li>Instantiate the initial World (using Prefabs).</li> <li>Orchestrate the update loop order.</li> </ol>"},{"location":"guides/PROJECT_STRUCTURE/#3-workflow-example-adding-a-feature","title":"3. Workflow Example: Adding a Feature","text":"<p>To add a new feature (e.g., \"Stamina\") to your game, follow this strict flow:</p> <ol> <li>Define Data: Create <code>src/my_game/components/stamina.py</code> (Dataclass: <code>val</code>, <code>regen_rate</code>).</li> <li>Define Logic: Create <code>src/my_game/systems/stamina_system.py</code>.<ul> <li>Logic: Decrease on action, increase over time.</li> </ul> </li> <li>Register Logic: Add <code>StaminaSystem</code> to <code>bootstrap.py</code>.</li> <li>Update Prefab: Add the <code>Stamina</code> component to <code>src/my_game/prefabs/player.py</code>.</li> <li>Execute: Inject <code>StaminaSystem</code> into your <code>GameplayScene</code> and call <code>stamina_system.update(dt)</code> in the loop.</li> </ol>"},{"location":"guides/PROJECT_STRUCTURE/#4-best-practices","title":"4. Best Practices","text":"Category Do Don't Dependencies Use <code>container.get()</code> in Scenes. Import global variables or singletons manually. State Store state in <code>Components</code>. Store state in <code>System</code> classes (Systems should be stateless logic processors). Testing Write tests in <code>tests/</code> mocking the DI Container. Test logic by running the game manually. Assets Load assets via <code>ResourceManager</code>. Hardcode file paths (e.g., <code>\"C:/Users/...\"</code>). Physics Use <code>PhysicsSystem</code> for movement. Manually update <code>transform.position</code> for physics objects."},{"location":"guides/PROJECT_STRUCTURE/#5-testing-architecture","title":"5. Testing Architecture","text":"<p>Because PyGuara uses Dependency Injection, your game logic is highly testable. You can test a system without opening a window.</p> <p>Example Test Structure (<code>tests/test_combat.py</code>):</p> <pre><code>def test_player_takes_damage():\n    # Setup\n    em = EntityManager()\n    system = CombatSystem(em)\n    player = create_player(em, Vector2(0,0))\n\n    # Act\n    system.apply_damage(player, 10)\n\n    # Assert\n    assert player.get_component(Health).current == 90\n\n</code></pre>"},{"location":"physics/simulation/","title":"Physics System","text":"<p>PyGuara integrates Pymunk (Chipmunk2D) for physics simulation, abstracted behind the <code>IPhysicsEngine</code> protocol.</p>"},{"location":"physics/simulation/#components","title":"Components","text":""},{"location":"physics/simulation/#rigidbody","title":"RigidBody","text":"<p>Represents a physical object. - Dynamic: Affected by forces and gravity. - Static: Immovable (walls, ground). - Kinematic: Moved by code but affects dynamic bodies (platforms).</p>"},{"location":"physics/simulation/#collider","title":"Collider","text":"<p>Defines the collision shape and properties. - Shapes: <code>BOX</code>, <code>CIRCLE</code>. - Properties: Friction, Restitution (bounciness), Density. - Trigger: <code>is_sensor=True</code> makes it a non-solid trigger volume.</p>"},{"location":"physics/simulation/#physicssystem","title":"PhysicsSystem","text":"<p>The <code>PhysicsSystem</code> synchronizes the ECS <code>Transform</code> component with the Pymunk body simulation. - Pre-Step: Updates Pymunk bodies if ECS transforms changed (Kinematic/Manual). - Step: Advances simulation (<code>dt</code>). - Post-Step: Updates ECS transforms from Pymunk bodies (Dynamic).</p>"},{"location":"physics/simulation/#collision-handling","title":"Collision Handling","text":"<p>Collisions generate events via the <code>CollisionSystem</code>.</p> <ul> <li><code>OnCollisionBegin</code>: Physical contact started.</li> <li><code>OnCollisionEnd</code>: Physical contact ended.</li> <li><code>OnTriggerEnter</code>: Entered a trigger volume.</li> </ul> <pre><code>def on_collision(self, event: OnCollisionBegin):\n    print(f\"Entities {event.entity_a} and {event.entity_b} collided!\")\n</code></pre>"},{"location":"systems/animation/","title":"Animation System","text":"<p>The Animation system (<code>pyguara.animation</code>) provides powerful tweening capabilities for smooth state transitions.</p>"},{"location":"systems/animation/#tweening","title":"Tweening","text":"<p>The <code>Tween</code> class allows you to animate any numeric property (float or tuple of floats) over time using easing functions.</p>"},{"location":"systems/animation/#features","title":"Features","text":"<ul> <li>Flexible Targets: Animate <code>Vector2</code>, <code>Color</code>, or simple <code>float</code> values.</li> <li>Easing Functions: Includes standard easings (Linear, EaseInQuad, EaseOutBounce, etc.).</li> <li>Lifecycle Control: Start, Pause, Resume, Stop, and Loop animations.</li> <li>Yoyo Mode: Automatically reverse animation on loop.</li> <li>Callbacks: <code>on_update</code> and <code>on_complete</code> hooks.</li> </ul>"},{"location":"systems/animation/#usage","title":"Usage","text":"<pre><code>from pyguara.animation.tween import Tween, TweenManager\nfrom pyguara.animation.easing import EasingType\n\n# Create a tween\ntween = Tween(\n    start_value=Vector2(0, 0),\n    end_value=Vector2(100, 100),\n    duration=1.0,\n    easing=EasingType.EASE_OUT_QUAD,\n    loops=-1,  # Infinite\n    yoyo=True  # Ping-pong\n)\n\n# Register with manager (usually injected)\ntween_manager.add(tween)\ntween.start()\n</code></pre>"},{"location":"systems/animation/#integration","title":"Integration","text":"<p>The <code>TweenManager</code> should be updated every frame. In a standard setup, this is handled automatically by the <code>AnimationSystem</code>.</p>"},{"location":"systems/editor/","title":"Editor &amp; Tools","text":"<p>PyGuara includes a built-in developer overlay (<code>pyguara.editor</code> &amp; <code>pyguara.tools</code>) powered by Dear ImGui.</p>"},{"location":"systems/editor/#tool-manager","title":"Tool Manager","text":"<p>The <code>ToolManager</code> coordinates all debug tools. It handles: *   Visibility: Toggling the global overlay (Default: F12). *   Input: Routing mouse/keyboard events to tools before the game, allowing UI interaction without triggering game actions.</p>"},{"location":"systems/editor/#the-editor","title":"The Editor","text":"<p>The Editor is a comprehensive debugging suite featuring:</p> <ul> <li>Hierarchy Panel: View the current scene's entity tree.</li> <li>Inspector Panel: View and edit Components on selected entities in real-time.<ul> <li>Reflection: Automatically generates UI for any <code>dataclass</code> component.</li> <li>Live Editing: Changes apply immediately to the running game.</li> </ul> </li> <li>Assets Panel: Browse project resources and spawn entities from data.</li> <li>Scene Serialization: Save and Load scenes directly from the \"File\" menu.</li> </ul>"},{"location":"systems/editor/#creating-custom-tools","title":"Creating Custom Tools","text":"<p>You can create custom debug tools by inheriting from <code>Tool</code>:</p> <pre><code>from pyguara.tools.base import Tool\nimport imgui\n\nclass MyDebugTool(Tool):\n    def __init__(self, container):\n        super().__init__(\"My Tool\", container)\n\n    def render(self, renderer):\n        imgui.begin(\"My Custom Window\")\n        imgui.text(\"Hello World\")\n        imgui.end()\n</code></pre>"},{"location":"systems/input/","title":"Input System","text":"<p>The <code>InputManager</code> (<code>pyguara.input</code>) acts as a powerful translation layer between hardware inputs and game actions.</p>"},{"location":"systems/input/#architecture","title":"Architecture","text":"<ol> <li>Backends: Abstracts the underlying library (e.g., <code>SDL2</code>, <code>Pygame</code>).</li> <li>Raw Input: Captures low-level events (Key presses, Joystick axis).</li> <li>Action Binding: Maps raw inputs to Semantic Actions (e.g., \"SPACE\" -&gt; \"Jump\").</li> <li>Action Dispatch: Emits <code>OnActionEvent</code> for game logic to consume.</li> </ol>"},{"location":"systems/input/#features","title":"Features","text":"<ul> <li>Action-Based: Code against actions (\"Jump\", \"Fire\"), not keys (<code>K_SPACE</code>). This supports easy rebinding.</li> <li>Contexts: Support for input contexts (e.g., <code>GAMEPLAY</code>, <code>MENU</code>) to reuse keys for different actions.</li> <li>Gamepad Support: Native support for controllers with axis deadzones and hot-plugging.</li> <li>Event-Driven: Clean integration with the global event system.</li> </ul>"},{"location":"systems/input/#usage","title":"Usage","text":""},{"location":"systems/input/#1-register-actions","title":"1. Register Actions","text":"<pre><code>input_manager.register_action(\"Jump\", ActionType.PRESS)\ninput_manager.register_action(\"MoveX\", ActionType.ANALOG)\n</code></pre>"},{"location":"systems/input/#2-bind-keys","title":"2. Bind Keys","text":"<pre><code>input_manager.bind_input(InputDevice.KEYBOARD, pygame.K_SPACE, \"Jump\")\ninput_manager.bind_input(InputDevice.GAMEPAD, 0, \"Jump\") # Button A\n</code></pre>"},{"location":"systems/input/#3-handle-events","title":"3. Handle Events","text":"<pre><code>def on_action(self, event: OnActionEvent):\n    if event.action_name == \"Jump\" and event.value &gt; 0.5:\n        self.player.jump()\n</code></pre>"},{"location":"systems/resources/","title":"Resource Management","text":"<p>The <code>ResourceManager</code> (<code>pyguara.resources</code>) is the central asset hub.</p>"},{"location":"systems/resources/#features","title":"Features","text":"<ul> <li>Unified Access: Load assets via <code>manager.load(\"path/to/asset.png\", Texture)</code>.</li> <li>Type Safety: Enforces return types (raises error if you load a Sound as a Texture).</li> <li>Caching: Implements the Flyweight pattern to ensure assets are loaded only once.</li> <li>Indexing: Scans directories to allow loading files by filename (e.g., \"player\") instead of full path.</li> </ul>"},{"location":"systems/resources/#loaders","title":"Loaders","text":"<p>The system uses the Strategy Pattern for loading different file types. - <code>JsonLoader</code>: Loads <code>.json</code> into <code>DataResource</code>. - <code>PygameImageLoader</code>: Loads images into <code>Texture</code>. - <code>PygameSoundLoader</code>: Loads audio into <code>AudioClip</code>.</p>"},{"location":"systems/resources/#audio-system","title":"Audio System","text":"<p>The <code>IAudioSystem</code> (<code>pyguara.audio</code>) protocol abstracts audio playback.</p> <ul> <li>SFX: \"Fire and forget\" sound effects (<code>play_sfx</code>).</li> <li>Music: Streamed audio with looping and fading (<code>play_music</code>).</li> <li>Backends: Currently implemented via <code>PygameAudioSystem</code>.</li> </ul>"},{"location":"systems/resources/#persistence","title":"Persistence","text":"<p>The persistence layer (<code>pyguara.persistence</code>) handles Saving and Loading game data.</p> <ul> <li>Serialization: Supports JSON (default) and Binary/Pickle formats.</li> <li>Integrity: Calculates MD5 checksums to detect save file corruption.</li> <li>Metadata: Stores timestamps, engine version, and save version alongside data for migration support.</li> </ul>"},{"location":"systems/scripting/","title":"Scripting System","text":"<p>PyGuara utilizes Python Coroutines (<code>pyguara.scripting</code>) to enable sequential, time-based game logic without the complexity of state machines or callback hell. This is similar to Unity's Coroutines.</p>"},{"location":"systems/scripting/#concepts","title":"Concepts","text":"<ul> <li>Coroutine: A Python generator function that <code>yields</code> control back to the engine.</li> <li>WaitInstruction: Objects yielded to control timing (<code>WaitForSeconds</code>, <code>WaitUntil</code>).</li> <li>CoroutineManager: Manages the execution and lifecycle of active coroutines.</li> </ul>"},{"location":"systems/scripting/#wait-instructions","title":"Wait Instructions","text":"<ul> <li><code>WaitForSeconds(duration)</code>: Pause execution for <code>duration</code> seconds.</li> <li><code>WaitUntil(predicate)</code>: Pause until <code>predicate()</code> returns True.</li> <li><code>WaitWhile(predicate)</code>: Pause while <code>predicate()</code> returns True.</li> </ul>"},{"location":"systems/scripting/#usage","title":"Usage","text":"<pre><code>from pyguara.scripting.coroutines import wait_for_seconds\n\ndef scripted_sequence():\n    print(\"Sequence started\")\n\n    # Wait for 2 seconds\n    yield wait_for_seconds(2.0)\n\n    print(\"2 seconds passed, spawning enemies...\")\n    spawn_enemies()\n\n    # Wait until all enemies are defeated\n    yield wait_until(lambda: get_enemy_count() == 0)\n\n    print(\"Wave cleared!\")\n\n# Start the coroutine\ncoroutine_manager.start_coroutine(scripted_sequence())\n</code></pre>"}]}