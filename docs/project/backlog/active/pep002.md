# PEP-2026-002: Path to Beta & Architectural Hardening

**Status:** Proposed
**Target Release:** v0.2.0-beta
**Date:** 2026-01-17

## 1. Executive Summary

PyGuara has established a production-grade code foundation with a robust ECS and DI architecture. However, to meet the self-imposed criteria for a "Beta" launch, the project must transition from a "Code Framework" to a "Product."

This proposal consolidates recent feedback into three critical pillars:

1. **Core Hardening:** Solving architectural bottlenecks in the Game Loop and ECS memory layout.
2. **Feature Completeness:** Elevating the Audio system from a wrapper to a game-ready feature set.
3. **Productization:** Adding the necessary tooling (Export, Asset Settings) to make the engine usable by third parties.

---

## 2. Core Architecture Optimization

### 2.1. Fixed Timestep Game Loop (Critical)

**Problem:** The current variable time step (`dt = clock.tick() / 1000.0`) couples simulation quality to frame rate. Lag causes physics tunneling and non-deterministic behavior.
**Proposal:** Implement the "Accumulator" pattern.

* **Logic:** Decouple `render()` from `update()`.
* **Implementation:** Run `physics_system.update()` at a fixed 60Hz (0.016s), regardless of the display framerate. Use interpolation for rendering to ensure smoothness.

### 2.2. ECS Fast-Path & Memory Layout

**Problem:**

1. Python object overhead: `Component` classes lacking `__slots__` consume excessive RAM and cache.
2. Wrapper bottleneck: `get_entities_with()` yields `Entity` objects, forcing slow `__getattr__` lookups in hot loops.
**Proposal:**

* **Enforce `__slots__`:** Update `BaseComponent` and all subclasses to use `__slots__` for memory compaction.
* **Fast-Path API:** Add `EntityManager.get_components(T1, T2)` that yields tuples `(Component1, Component2)` directly, bypassing the `Entity` wrapper object for high-performance systems (Physics/Rendering).

### 2.3. Dependency Injection Safety

**Problem:** The DI container relies on reflection, which is slow. Misuse of `container.get()` inside `update()` loops will destroy performance.
**Proposal:**

* **Linting/Guard:** Add debug-mode warnings if `container.get()` is called after the initialization phase.
* **Documentation:** Explicitly forbid Service Locator pattern in Systems; enforce Constructor Injection.

---

## 3. Feature Gap Closure

### 3.1. Audio System Maturity (Beta Blocker)

**Problem:** The current audio system is a policy wrapper around Pygame with hardcoded volumes and no spatial capabilities.
**Proposal:**

* **Spatial Audio:** Implement `play_at_position(clip, world_pos)` in `IAudioSystem`. Calculate distance attenuation and stereo panning relative to the active Camera.
* **Audio Buses:** Replace hardcoded `_sfx_volume` with a dynamic `AudioBus` topology (Master -> SFX/Music/Voice). Allow users to route sounds to specific buses.
* **Priority System:** Implement channel stealing based on priority (e.g., `play(..., priority=CRITICAL)` stops a `LOW` priority sound if channels are full).

### 3.2. Rendering Migration

**Problem:** The engine is currently in flux between Pygame rendering and ModernGL.
**Proposal:** Prioritize closing the ModernGL migration. A Beta cannot launch with an unstable or deprecated rendering backend.

---

## 4. Productization & Tooling

### 4.1. Build & Export Workflow (DX)

**Problem:** There is no mechanism for a user to distribute their game.
**Proposal:**

* **CLI Tool:** Implement `pyguara build` command.
* **Backend:** Wrap **PyInstaller** or **Nuitka**. Automate the inclusion of assets and the engine runtime into a standalone executable.

### 4.2. Asset Import Pipeline

**Problem:** Assets are loaded "raw." There is no way to define import settings (e.g., Filtering: Nearest vs. Linear, Audio: Stream vs. Load).
**Proposal:** Implement a `.meta` file sidecar system (e.g., `hero.png.meta`) to store import configurations that the `ResourceManager` respects.

---

## 5. Content & Validation

### 5.1. The "Big Three" Examples

**Requirement:** The `Architecture & Style Guide` demands "3+ complete example games" for Beta.
**Plan:** Develop three distinct mini-games to prove engine versatility:

1. **Platformer:** Validates Physics, Collision, Input (Gamepad).
2. **Top-Down Shooter:** Validates Spatial Audio, Particle Systems, High Entity Count.
3. **Puzzle/UI Game:** Validates UI System, Mouse Input, Scene Transitions.

### 5.2. Education Material

**Requirement:** "Tutorial series complete".
**Plan:** Create a "Zero to Hero" text tutorial series: "Making your first PyGuara Game," specifically explaining the ECS mindset to new users.

---

## 6. Prioritized Roadmap

**Phase 1: The Core (Weeks 1-2)** - ✅ COMPLETE

1. ✅ Fix Game Loop (Fixed Timestep) - Accumulator pattern with PhysicsConfig
2. ✅ Optimize ECS (Slots + Tuple Query) - `__slots__` on BaseComponent + `get_components()` fast-path
3. ✅ Finish ModernGL Rendering Migration - Complete (v0.3.0)

**Phase 2: The Systems (Weeks 3-4)** - ✅ COMPLETE

1. ✅ Refactor Audio (Spatial + Buses) - Complete:
   - `play_sfx_at_position()` with distance attenuation and stereo panning
   - `AudioBusManager` with hierarchy (Master → SFX/Music/Voice)
   - `AudioPriority` enum with channel stealing
   - `SpatialAudioConfig` for customizable falloff
2. ✅ Implement Asset `.meta` system - Complete:
   - `TextureMeta`, `AudioMeta`, `SpritesheetMeta` types
   - `MetaLoader` for reading `.meta` sidecar files
   - `IMetaAwareLoader` protocol for loaders
   - `PygameImageLoader` updated to apply meta settings

**Phase 3: The Product (Weeks 5-6)**

1. Create `pyguara build` tool.
2. Develop the 3 Demo Games.
3. Write Documentation/Tutorials.

**Decision:**
Launch Beta only upon completion of Phase 3. Market strictly as a **"Single-Player 2D Engine"** (delaying Networking to post-1.0).
